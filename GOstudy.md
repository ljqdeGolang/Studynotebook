# Go study

## GO语言视频学习笔记

**区块链介绍**

python解决了机器学习的问题，区块链解决了机器与机器之间的信任问题。

人工智能解决解放生产力问题，区块链解决生产关系问题。

**基础**

并发：分布式服务器、语言层面并发。

类型转换：习惯将低类型转为高类型。

switch不能用浮点类型。



如果函数的参数为不定参`func add(a ...int)`，传递参数方式a[0:]...   用len获得不定参的长度。

函数可以返回多个返回值，函数名本身就是一个指针类型数据，在内存中代码区进行储存。函数中的的信息在栈区储存，用完就销毁。

函数类型`  type  name  func(int,int) int `  其实就是一个指针类型。



匿名内部函数：不能调用只能内部使用。

匿名函数 `func (a int) int {}(30)`  括号加实参可以调用这个函数了，也可以将其赋值给其他变量，如： f:=`func(a int) int { },`    f(30)成立。

闭包：通过匿名函数和闭包可以实现栈区的本地化。



工程管理：`src`：源码文件夹  `pkg`: “.a”的归档文件。`bin`：`go install`安装形成的可执行文件

数组：指定数组下标进行初始化值，var array [10]int{6:10}，第七个元素为10。

随机数：导入头文件：math/rand time；添加随机数种子；使用随机数

`rand.Intn() 	rand.Seed(time.Now().Unixnano()) `。

切片存在内存的堆区，当用append扩充时，可能会导致地址发生变化。copy拷贝切片后，会形成两个独立的空间，不会相互影响。

map在定义时，key必须是唯一的，map在函数中作为参数是引用传递(地址传递)

go通过匿名字段（即：结构体）来表现继承的思想。

方法：`func (s stu)add(){} `只要是满足`stu`类都可以调用此方法。 子类结构体继承父类结构体，允许使用父类结构体成员，允许使用父类的方法。父类不能继承子类信息 。

接口定义了规则，方法实现了规则。接口是虚的，方法是实的。

多态实现了接口的统一处理，就是将接口类型作为函数参数，如：`func UseDev(use USBer){} `其中`USBer`是一个接口。

接口赋值需要赋地址，不能直接赋值。接口中的方法必须有具体的实现，否则不能将只实现某一个方法的对象赋值给接口变量。且接口里的方法只能是一种对象（继承父类的对象也可以）实现的方法。

超集：继承子集接口的接口，超集可以转换为子集。

设计模式：对于面向对象基于MVC，有26种。

`recover `与`defer`要联合起来使用，`recover`返回值为接口类型，`recover`的使用一定要在错误之前调用，其原理是从panic手上夺得控制权，后面的程序就不会运行了。

`os`包是文件创建的包，`\`在go语言中被认为是转义字符，所以反斜杠用`\\`,也可以用正斜杠`/`来作为文件目录。创建文件例子：

```go
//创建文件，文件不存在时，建个新的，存在时，会覆盖原内容 
fp,err :=os.Create(
    "D:/edgexiazai/a.txt")
if err !=nil {
	fmt.Println("文件创建失败")
	return
}
defer fp.Close()
//写入文件
fp.Weitestring("mike")
fp.Write(b []byte)
fp.WriteAt(buf []byte,n)//指定位置插入内容
//打开文件
fp.Open()
fp.OpenFile(文件名 string，打开模式 os.0_RDWR,打开权限 int)
//获取文件字符个数
fp.Seek()
//读文件
fp.Read()
fp.ReadAt()
r:=bufio.NewReader(fp)
b,_:=r.ReadBytes('\n')// 创建缓冲区，在读取内容。\n位置为分隔符 //EOF 值为-1 文件结束标志
//循环读取文件
for {
    n,err :=fp.Read(b)
    if err ==io.EOF { break }
    fmt.Print(string(b[:n]))
}
//第二种
r:=bufio.NewReader(fp)
for {
    b,err:=r.ReaderBytes('\n')
    fmt.Println(string(b))
    if err ==io.EOF {
        break
    }
}
```

strings包：`contains`判断是否包含某个字符串；`Join`讲一个字符串切片拼接成一个字符串；`index`查找另一个字符是否存在，返回下标；`Repeat`将一个字符串重复N次；`Replace`替换字符；`Spilt`切分字符串；`Trim`去掉字符串前后指定内容；`Fields`去掉字符串中的空格，并返回有效数据切片；

`strconv`包：字符串类型转换：有`FormatBool`、`FormatInt`、`Itoa`、`FormatFloat(数据，'f',保留小数位置;位数)`、`PraseBool`、`Atoi`

将数据转换为字符添加给字符串：`AppendBool、AppendInt`  

**`GTK`窗口程序开发：**

第一梯队：`MFC(opengl等)、C#、QT`  第二梯队：`GTK、GUI`

- **进阶：**

  **内存布局**

  ![image-20210304111315529](C:\Users\LJQ\AppData\Roaming\Typora\typora-user-images\image-20210304111315529.png)
  
  栈帧：用来给函数运行提供内存空间，取内存于stack（栈 ）上，当函数调用时，产生栈帧，函数调用结束，释放栈帧。栈帧存储：1、局部变量 2、形参 3、内存字段描述值（储存栈顶、栈底指针值）
  
  变量存储：等号 左边的变量，代表 变量所指向的内存空间。	（写）
  

​            等号 右边的变量，代表 变量内存空间存储的数据值。	（读）

传地址（引用）：将形参的地址值作为函数参数传递。

传值（数据据）：将实参的值拷贝一份给形参。

传引用：	在A栈帧内部，修改B栈帧中的变量值。

**切片**：不是一个数组的指针，是一种数据结构体，用来操作数组内部元素。

```go
  切片名称 [ low : high : max ]
low: 起始下标位置
  high：结束下标位置	len = high - low
容量：cap = max - low
  截取数组，初始化切片时，没有指定切片容量时,切片容量跟随原数组（切片）。
	s[:high:max] :从0开始，到high结束（不包含）.
  	s[low:] :从low开始，到末尾
	s[: high]:从0开始，到high结束。容量跟随原先容量。【常用】
  切片做函数参数 —— 传引用。（传地址）
  append：在切片末尾追加元素
  	append(切片对象， 待追加元素）
  	向切片增加元素时，切片的容量会自动增长。1024 以下时，一两倍方式增长。
  copy：
  	copy（目标位置切片， 源切片） 拷贝过程中，直接对应位置拷贝。
```
  **map**： 

  ```go
  key： 唯一、无序。 不能是引用类型数据。
  map 不能使用 cap（）
  创建方式：
  	1.  var m1 map[int]string		--- 不能存储数据（只声明map，没有空间，不能直接存储key--value。）
  
  	2. m2 := map[int]string{}		---能存储数据
  
	3. m3 := make(map[int]string)		---默认len = 0
  
  	4. m4 := make(map[int]string, 10)
  
  初始化：
  
  	1. var m map[int]string = map[int]string{ 1: "aaa", 2:"bbb"}	保证key彼此不重复。
  
  	2. m := map[int]string{ 1: "aaa", 2:"bbb"}
  
  赋值:
  
  	赋值过程中，如果新map元素的key与原map元素key 相同 	——> 覆盖（替换）
  
  	赋值过程中，如果新map元素的key与原map元素key 不同	——> 添加
  
  map的使用：
  		  
  	遍历map：
  
  		for  key值， value值 := range map {
  		} 
  
  		for  key值 := range map {
  		}	
  
  	判断map中key是否存在。
  
  		 map[下标] 运算：返回两个值， 第一个表 value 的值，如果value不存在。 nil
  		第二个表 key是否存在的bool类型。存在 true， 不存在false
  
  	删除map：
  		delete()函数： 参1： 待删除元素的map	参2： key值
  		delete（map， key）删除一个不存在的key ， 不会报错。
  		map 做函数参数和返回值，传引用。
  ```

  **线程进程**：

  *并行*：借助多核`cpu`实现    【真 并行】

  *并发*：宏观：用户体验上，程序在并行执行					【假 并行】

  ​			微观：多个计划任务，顺序执行。在飞速的切换，轮换使用`CPU`时间轮片。 

*进程并发*：

​			程序：编译成功得到的二进制文件。    占用磁盘空间    死的  1

​			进程：运行起来的程序。     占用系统资源（内存）     活的  N

进程的状态：初始态、就绪态、运行态、挂起（阻塞）态、终止态。

*线程并发*：

​		线程：`LWP`：轻量级的进程。	最小的执行单位。  —`cpu`分配时间轮片的对象

​		进程：最小的系统资源分配的单位。

*同步*：为了数据混乱，解决与时间有关的错误

​		协同步调：规划先后顺序 

​		携程同步机制：

​				互斥锁（互斥量）：建议锁。拿到锁以后，才能访问数据，没有拿到锁的线程，阻塞等待。拿到锁的线程放锁。

​				读写锁：一把锁（读属性、写属性）。 写独占，读共享。写锁优先级高。 

*协程并发*：`Python、Lua、Ruset`    提高程序执行效率

​		协程： 轻量级的线程

总结：进程并发：稳定性强。线程并发：节省资源。协程并发：效率高



## 《Go程序设计语言》（go语言圣经）笔记

### 1、入门

运行命令：

`go run `运行go程序、`go build`编译go程序二进制、`go install`安装包 `go doc` 读取标准文档 、`go mod init moudlename`初始化模块、`go mod tidy`加载项目包依赖项及清除未使用包。

声明: 没有初始化值，定义：进行了初始化值。

打印：print 没有换行符，`println`有换行符。

- `printf`格式化输出（用占位符）：`%3d`,格式化三位输出，不足补空格（int类型），`%.3f`，保留三位小数（浮点型）`%t:bool`类型 `  %c: byte`类型  ` %s: string`类型  ` %p`: 内存地址占位符   `%T`打印对应的数据类型   ` %b:`打印二进制。

输入：Scan 示例：`fmt.Scan(&a)  ，Scanf。`

字符串中存贮了字符串结束标志"\0"、“\ \”表示只有一个斜杠，常用于文件操作。

range遍历它能遍历数组、切片、字典、通道。

### 2、程序结构

#### 2.1 命名

Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。

大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。

一般采用驼峰式命名法。

#### 2.2 声明

声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：`var、const、type和func`，分别对应变量、常量、类型和函数实体对象的声明。

包一级的声明是可在整个包对应的每个源文件中访问。

全局变量、常量存储在内存的数据区，局部变量储存在内存的栈区。

go语言中常量的类型是不确定的，如果需要它的值的时候，可以改变它的默认类型，不会报错。

- 比如：

```
const a =100
s =math.Sin(a)  //这里需要的是Float64类型，但可以临时改变常量a的类型
```

#### 2.3 变量

变量声明的一般语法如下：

```Go
var 变量名字 类型 = 表达式  //在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。
```

一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：

```Go
var f, err = os.Open(name) // os.Open returns a file and an error
```

常量存在内存的数据区，而变量存在栈区。

1）简短变量声明

简短声明变量：在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。

简短变量声明语句中必须至少要声明一个新的变量。

2）指针

如果用“var x int”声明语句声明一个x变量，那么&x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是`*int`，指针被称之为“指向int类型的指针”。

```go
var *p int，*p=100,这里的*p又称为解引用。
p=new(int)在堆上开辟新的空间.
空指针：未被初始化的指针。	var p *int		*p --> err
野指针：被一片无效的地址空间初始化。
```

3）new函数

另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为`*T`。

4）变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。

基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。

#### 2.4 赋值

1）元组赋值

元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。

2）可赋值性

不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。

对于两个值是否可以用`==`或`!=`进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。

#### 2.5 类型

变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。

```go
type 类型名字 底层类型
```

对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如`(*int)(0)`）。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。

#### 2.6 包和文件

Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。

还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的。

1）导入包

在Go语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似"gopl.io/ch2/tempconv"的字符串对应包的导入路径。

2）包的初始化

包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化

#### 2.7 作用域

声明语句的作用域是指源代码中可以有效使用这个名字的范围。

不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。

### 3 基础数据类型

Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。本章介绍基础类型，包括：数字、字符串和布尔型。复合数据类型——数组和结构体——是通过组合简单类型，来表达更加复杂的数据结构。引用类型包括指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用。

#### 3.1 整型

Go语言的数值类型包括几种不同大小的整数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。

整型就是整数类型，有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。

尽管Go语言提供了无符号数的运算，但即使数值本身不可能出现负数，我们还是倾向于使用有符号的int类型，就像数组的长度那样，虽然使用uint无符号类型似乎是一个更合理的选择。无符号数往往只有在位运算或其它特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。

当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式。

字符使用`%c`参数打印，或者是用`%q`参数打印带单引号的字符

#### 3.2 浮点数

Go语言提供了两种精度的浮点数，float32和float64。

用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。

#### 3.3 复数

Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：

```go
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"
```

#### 3.4 布尔型

一个布尔类型的值只有两种：true和false。

`&&`的优先级比`||`高

#### 3.5 字符串

一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。

内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i< len(s)条件约束。

字符串可以用==和<进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。

一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。

1）字符串面值

因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中。

一个原生的字符串面值形式是`...`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行。原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。

2）Unicode

Unicode（ http://unicode.org ），它收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符等，每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型）

UTF8是一个将Unicode码点编码为字节序列的变长编码。unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等），unicode/utf8包则提供了用于rune字符序列的UTF8编码和解码的功能。

rune类型与byte类型

ASCii编码字节打印出的是十进制数，UTF-8打印出的也是十进制数。

unicode（符号集）并没有规定存储方式，而UTF-8是unicode的实现方式之一，是变长的编码方式。

在go中打印rune类型时，一般会采用简短的unicode符号方式，而打印byte类型时，一个字节就只能是ASCII编码方式来表示，为了表示出unicode符号集对应的汉字，所以要表示成utf-8对应的编码。

go语言中的字节类型表示中文的时候，打印的是三个ASCii编码方式的二进制，这几个二进制的表示是依靠的UTF-8编码方式，三个字节的二进制合起来就是表示这个汉字在unicode字符集中的utf-8编码方式。

3）字符串和数字的转换

将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用strconv.Itoa(“整数到ASCII”)。

```go
x := 123
y := fmt.Sprintf("%d", x)
fmt.Println(y, strconv.Itoa(x)) // "123 123"
```

如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数：

```go
x, err := strconv.Atoi("123")             // x is an int
y, err := strconv.ParseInt("123", 10, 64) // base 10, up to 64 bits
```

#### 3.6 常量

每种常量的潜在类型都是基础类型：boolean、string或数字。

如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。例如：

```
const (
    a = 1
    b
    c = 2
    d
)

fmt.Println(a, b, c, d) // "1 1 2 2"
```

常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。

1）无类型常量

这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。

### 4 复合数据类型

#### 4.1 数组

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。

数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。

## GO语言基础学习

2、切片

```go
f :=[]string{"sws","gao"}
s :=append(g, f...)  //这是成立的，将f就添加给g了
```

1、通道和并发

```go
go func chan int) { //读写均可的channel c } (a)
go func(c <- chan int) { //只读的Channel } (a)
go func(c chan <- int) {  //只写的Channel } (a)
```

2、接口对象执行的类型动态转换/查询——类型断言

```go
//1、具体值的类型断言
a,ok :=v.([]byte)//判断接口v的底层是否保存了字节切片类型的值，如果有，就返回ok=1 

//2、接口类型的类型断言，还未搞懂
type arg interface {}
a := arg.(int) //将arg保存的底层int值传给a，如果arg接口没有Int值，会panic

```

3、当用range遍历切片时，改变其值，也能改变切片的值。

4、下面的条件语句中的中断命令跳出循环的情况。

```go
for i:=range A {
	switch {
	case n==1:
		break //这里的break没有作用，因为会默认为跳出switch
	case n!=1:
		continue //这里的continue是有作用的，可以跳出本次for循环
	}
    
    //下面的都能跳出for循环
	if n>1 {
		break
	}
	if n<1 {
		continue
	}
}
```

 