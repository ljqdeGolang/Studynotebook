# Go study

## GO语言视频学习笔记

**区块链介绍**

python解决了机器学习的问题，区块链解决了机器与机器之间的信任问题。

人工智能解决解放生产力问题，区块链解决生产关系问题。

**基础**

并发：分布式服务器、语言层面并发。

类型转换：习惯将低类型转为高类型。

switch不能用浮点类型。

如果函数的参数为不定参`func add(a ...int)`，传递参数方式a[0:]...   用len获得不定参的长度。

函数可以返回多个返回值，函数名本身就是一个指针类型数据，在内存中代码区进行储存。函数中的的信息在栈区储存，用完就销毁。

函数类型`  type  name  func(int,int) int `  其实就是一个指针类型。

匿名内部函数：不能调用只能内部使用。

匿名函数 `func (a int) int {}(30)`  括号加实参可以调用这个函数了，也可以将其赋值给其他变量，如： f:=`func(a int) int { },`    f(30)成立。

闭包：通过匿名函数和闭包可以实现栈区的本地化。



工程管理：`src`：源码文件夹  `pkg`: “.a”的归档文件。`bin`：`go install`安装形成的可执行文件



随机数：导入头文件：math/rand time；添加随机数种子；使用随机数

`rand.Intn() 	rand.Seed(time.Now().Unixnano()) `。

切片存在内存的堆区，当用append扩充时，可能会导致地址发生变化。copy拷贝切片后，会形成两个独立的空间，不会相互影响。

map在定义时，key必须是唯一的，map在函数中作为参数是引用传递(地址传递)

go通过匿名字段（即：结构体）来表现继承的思想。

方法：`func (s stu)add(){} `只要是满足`stu`类都可以调用此方法。 子类结构体继承父类结构体，允许使用父类结构体成员，允许使用父类的方法。父类不能继承子类信息 。

接口定义了规则，方法实现了规则。接口是虚的，方法是实的。

多态实现了接口的统一处理，就是将接口类型作为函数参数，如：`func UseDev(use USBer){} `其中`USBer`是一个接口。

接口赋值需要赋地址，不能直接赋值。接口中的方法必须有具体的实现，否则不能将只实现某一个方法的对象赋值给接口变量。且接口里的方法只能是一种对象（继承父类的对象也可以）实现的方法。

超集：继承子集接口的接口，超集可以转换为子集。

设计模式：对于面向对象基于MVC，有26种。

`recover `与`defer`要联合起来使用，`recover`返回值为接口类型，`recover`的使用一定要在错误之前调用，其原理是从panic手上夺得控制权，后面的程序就不会运行了。

`os`包是文件创建的包，`\`在go语言中被认为是转义字符，所以反斜杠用`\\`,也可以用正斜杠`/`来作为文件目录。创建文件例子：

```go
//创建文件，文件不存在时，建个新的，存在时，会覆盖原内容 
fp,err :=os.Create(
    "D:/edgexiazai/a.txt")
if err !=nil {
	fmt.Println("文件创建失败")
	return
}
defer fp.Close()
//写入文件
fp.Weitestring("mike")
fp.Write(b []byte)
fp.WriteAt(buf []byte,n)//指定位置插入内容
//打开文件
fp.Open()
fp.OpenFile(文件名 string，打开模式 os.0_RDWR,打开权限 int)
//获取文件字符个数
fp.Seek()
//读文件
fp.Read()
fp.ReadAt()
r:=bufio.NewReader(fp)
b,_:=r.ReadBytes('\n')// 创建缓冲区，在读取内容。\n位置为分隔符 //EOF 值为-1 文件结束标志
//循环读取文件
for {
    n,err :=fp.Read(b)
    if err ==io.EOF { break }
    fmt.Print(string(b[:n]))
}
//第二种
r:=bufio.NewReader(fp)
for {
    b,err:=r.ReaderBytes('\n')
    fmt.Println(string(b))
    if err ==io.EOF {
        break
    }
}
```

**`GTK`窗口程序开发：**

第一梯队：`MFC(opengl等)、C#、QT`  第二梯队：`GTK、GUI`

- **进阶：**

  **内存布局**

  ![image-20210304111315529](C:\Users\LJQ\AppData\Roaming\Typora\typora-user-images\image-20210304111315529.png)
  
  栈帧：用来给函数运行提供内存空间，取内存于stack（栈 ）上，当函数调用时，产生栈帧，函数调用结束，释放栈帧。栈帧存储：1、局部变量 2、形参 3、内存字段描述值（储存栈顶、栈底指针值）
  
  变量存储：等号 左边的变量，代表 变量所指向的内存空间。	（写）
  

​            等号 右边的变量，代表 变量内存空间存储的数据值。	（读）

传地址（引用）：将形参的地址值作为函数参数传递。

传值（数据据）：将实参的值拷贝一份给形参。

传引用：	在A栈帧内部，修改B栈帧中的变量值。

  **线程进程**：

  *并行*：借助多核`cpu`实现    【真 并行】

  *并发*：宏观：用户体验上，程序在并行执行					【假 并行】

  ​			微观：多个计划任务，顺序执行。在飞速的切换，轮换使用`CPU`时间轮片。 

*进程并发*：

​			程序：编译成功得到的二进制文件。    占用磁盘空间    死的  1

​			进程：运行起来的程序。     占用系统资源（内存）     活的  N

进程的状态：初始态、就绪态、运行态、挂起（阻塞）态、终止态。

*线程并发*：

​		线程：`LWP`：轻量级的进程。	最小的执行单位。  —`cpu`分配时间轮片的对象

​		进程：最小的系统资源分配的单位。

*同步*：为了数据混乱，解决与时间有关的错误

​		协同步调：规划先后顺序 

​		携程同步机制：

​				互斥锁（互斥量）：建议锁。拿到锁以后，才能访问数据，没有拿到锁的线程，阻塞等待。拿到锁的线程放锁。

​				读写锁：一把锁（读属性、写属性）。 写独占，读共享。写锁优先级高。 

*协程并发*：`Python、Lua、Ruset`    提高程序执行效率

​		协程： 轻量级的线程

总结：进程并发：稳定性强。线程并发：节省资源。协程并发：效率高



## 《Go程序设计语言》（go语言圣经）笔记

### 1、入门

运行命令：

`go run `运行go程序、`go build`编译go程序二进制、`go install`安装包 `go doc` 读取标准文档 、`go mod init moudlename`初始化模块、`go mod tidy`加载项目包依赖项及清除未使用包。

声明: 没有初始化值，定义：进行了初始化值。

打印：print 没有换行符，`println`有换行符。

- `printf`格式化输出（用占位符）：`%3d`,格式化三位输出，不足补空格（int类型），`%.3f`，保留三位小数（浮点型）`%t:bool`类型 `  %c: byte`类型  ` %s: string`类型  ` %p`: 内存地址占位符   `%T`打印对应的数据类型   ` %b:`打印二进制。

输入：Scan 示例：`fmt.Scan(&a)  ，Scanf。`

字符串中存贮了字符串结束标志"\0"、“\ \”表示只有一个斜杠，常用于文件操作。

range遍历它能遍历数组、切片、字典、通道。

### 2、程序结构

#### 2.1 命名

Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。

大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。

一般采用驼峰式命名法。

#### 2.2 声明

声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：`var、const、type和func`，分别对应变量、常量、类型和函数实体对象的声明。

包一级的声明是可在整个包对应的每个源文件中访问。

全局变量、常量存储在内存的数据区，局部变量储存在内存的栈区。

go语言中常量的类型是不确定的，如果需要它的值的时候，可以改变它的默认类型，不会报错。

- 比如：

```
const a =100
s =math.Sin(a)  //这里需要的是Float64类型，但可以临时改变常量a的类型
```

#### 2.3 变量

变量声明的一般语法如下：

```Go
var 变量名字 类型 = 表达式  //在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。
```

一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：

```Go
var f, err = os.Open(name) // os.Open returns a file and an error
```

常量存在内存的数据区，而变量存在栈区。

1）简短变量声明

简短声明变量：在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。它以“名字 := 表达式”形式声明变量，变量的类型根据表达式来自动推导。

简短变量声明语句中必须至少要声明一个新的变量。

2）指针

如果用“var x int”声明语句声明一个x变量，那么&x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是`*int`，指针被称之为“指向int类型的指针”。

```go
var *p int，*p=100,这里的*p又称为解引用。
p=new(int)在堆上开辟新的空间.
空指针：未被初始化的指针。	var p *int		*p --> err
野指针：被一片无效的地址空间初始化。
```

3）new函数

另一个创建变量的方法是调用内建的new函数。表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为`*T`。

4）变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间段。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。

基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。

#### 2.4 赋值

1）元组赋值

元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值。在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。

2）可赋值性

不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。

对于两个值是否可以用`==`或`!=`进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。

#### 2.5 类型

变量或表达式的类型定义了对应存储值的属性特征，例如数值在内存的存储大小（或者是元素的bit个数），它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。

```go
type 类型名字 底层类型
```

对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如`(*int)(0)`）。只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。

#### 2.6 包和文件

Go语言中的包和其他语言的库或模块的概念类似，目的都是为了支持模块化、封装、单独编译和代码重用。

还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的。

1）导入包

在Go语言程序中，每个包都有一个全局唯一的导入路径。导入语句中类似"gopl.io/ch2/tempconv"的字符串对应包的导入路径。

2）包的初始化

包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化

#### 2.7 作用域

声明语句的作用域是指源代码中可以有效使用这个名字的范围。

不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。

### 3 基础数据类型

Go语言将数据类型分为四类：基础类型、复合类型、引用类型和接口类型。本章介绍基础类型，包括：数字、字符串和布尔型。复合数据类型——数组和结构体——是通过组合简单类型，来表达更加复杂的数据结构。引用类型包括指针、切片、字典、函数、通道，虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用。

#### 3.1 整型

Go语言的数值类型包括几种不同大小的整数、浮点数和复数。每种数值类型都决定了对应的大小范围和是否支持正负符号。

整型就是整数类型，有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。

尽管Go语言提供了无符号数的运算，但即使数值本身不可能出现负数，我们还是倾向于使用有符号的int类型，就像数组的长度那样，虽然使用uint无符号类型似乎是一个更合理的选择。无符号数往往只有在位运算或其它特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。

当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式。

字符使用`%c`参数打印，或者是用`%q`参数打印带单引号的字符

#### 3.2 浮点数

Go语言提供了两种精度的浮点数，float32和float64。

用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。

#### 3.3 复数

Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部：

```go
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"
```

#### 3.4 布尔型

一个布尔类型的值只有两种：true和false。

`&&`的优先级比`||`高

#### 3.5 字符串

一个字符串是一个不可改变的字节序列。字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。

内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i< len(s)条件约束。

字符串可以用==和<进行比较；比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。

一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。

1）字符串面值

因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中。

一个原生的字符串面值形式是`...`，使用反引号代替双引号。在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行，因此一个程序中的原生字符串面值可能跨越多行。原生字符串面值用于编写正则表达式会很方便，因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。

2）Unicode

Unicode（ http://unicode.org ），它收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符等，每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型）

UTF8是一个将Unicode码点编码为字节序列的变长编码。unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等），unicode/utf8包则提供了用于rune字符序列的UTF8编码和解码的功能。

rune类型与byte类型

ASCii编码字节打印出的是十进制数，UTF-8打印出的也是十进制数。

unicode（符号集）并没有规定存储方式，而UTF-8是unicode的实现方式之一，是变长的编码方式。

在go中打印rune类型时，一般会采用简短的unicode符号方式，而打印byte类型时，一个字节就只能是ASCII编码方式来表示，为了表示出unicode符号集对应的汉字，所以要表示成utf-8对应的编码。

go语言中的字节类型表示中文的时候，打印的是三个ASCii编码方式的二进制，这几个二进制的表示是依靠的UTF-8编码方式，三个字节的二进制合起来就是表示这个汉字在unicode字符集中的utf-8编码方式。

3）字符串和数字的转换

将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用strconv.Itoa(“整数到ASCII”)。

```go
x := 123
y := fmt.Sprintf("%d", x)
fmt.Println(y, strconv.Itoa(x)) // "123 123"
```

如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数：

```go
x, err := strconv.Atoi("123")             // x is an int
y, err := strconv.ParseInt("123", 10, 64) // base 10, up to 64 bits
```

strings包：`contains`判断是否包含某个字符串；`Join`讲一个字符串切片拼接成一个字符串；`index`查找另一个字符是否存在，返回下标；`Repeat`将一个字符串重复N次；`Replace`替换字符；`Spilt`切分字符串；`Trim`去掉字符串前后指定内容；`Fields`去掉字符串中的空格，并返回有效数据切片；

`strconv`包：字符串类型转换：有`FormatBool`、`FormatInt`、`Itoa`、`FormatFloat(数据，'f',保留小数位置;位数)`、`PraseBool`、`Atoi`

将数据转换为字符添加给字符串：`AppendBool、AppendInt`  

#### 3.6 常量

每种常量的潜在类型都是基础类型：boolean、string或数字。

如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。例如：

```
const (
    a = 1
    b
    c = 2
    d
)

fmt.Println(a, b, c, d) // "1 1 2 2"
```

常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。

1）无类型常量

这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。

### 4 复合数据类型

#### 4.1 数组

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。

`var a [3]int 、var q [3]int = [3]int{1, 2, 3}`

在数组字面值中，如果在数组的长度位置出现的是“...”省略号，则表示数组的长度是根据初始化值的个数来计算。

数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。

数组：指定数组下标进行初始化值，var array [10]int{6:10}，第七个元素为10。

#### 4.2 切片

Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。

因为其是对底层数组类型的引用，当用range遍历切片时，改变其值，也能改变切片的值。

一个slice由三个部分构成：指针、长度和容量。指针指向第一个slice元素对应的底层数组元素的地址；长度对应slice中元素的数目；长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。

如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大。

如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。

内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。

```Go
make([]T, len)
make([]T, len, cap) // same as make([]T, cap)[:len]
```

1）append 函数

内置的append函数用于向slice追加元素:

```go
f :=[]string{"sws","gao"}
s :=append(g, f...)  //这是成立的，将f就添加给g了
```

要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的。要更新这些信息需要像上面例子那样一个显式的赋值操作。从这个角度看，slice并不是一个纯粹的引用类型，它实际上是一个类似下面结构体的聚合类型：

```Go
type IntSlice struct {
    ptr      *int
    len, cap int
}
```

相关补充：

```go
  切片名称 s[ low : high : max ]
low: 起始下标位置
  high：结束下标位置	len = high - low
容量：cap = max - low
  截取数组，初始化切片时，没有指定切片容量时,切片容量跟随原数组（切片）。
	s[:high:max] :从0开始，到high结束（不包含）.
  	s[low:] :从low开始，到末尾
	s[: high]:从0开始，到high结束。容量跟随原先容量。【常用】
  切片做函数参数 —— 传引用。（传地址）
  append：在切片末尾追加元素
  	append(切片对象， 待追加元素）
  	向切片增加元素时，切片的容量会自动增长。1024 以下时，一两倍方式增长。
  copy：
  	copy（目标位置切片， 源切片） 拷贝过程中，直接对应位置拷贝。
```

#### 4.3 Map

哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。

在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。

内置的make函数可以创建一个map：

```Go
ages := make(map[string]int) // mapping from strings to ints
```

也可以用map字面值的语法创建map，同时还可以指定一些最初的key/value：

```Go
ages := map[string]int{
    "alice":   31,
    "charlie": 34,
}
```

但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作：

```Go
_ = &ages["bob"] // compile error: cannot take address of map element
```

Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同

相关补充：

```go
 key： 唯一、无序。 不能是引用类型数据。
  map 不能使用 cap（）
  创建方式：
  	1. var m1 map[int]string		--- 不能存储数据（只声明map，没有空间，不能直接存储key--value。）
  
  	2. m2 := map[int]string{}		---能存储数据
  
	3. m3 := make(map[int]string)		---默认len = 0
  
  	4. m4 := make(map[int]string, 10)
  
  初始化：
  
  	1. var m map[int]string = map[int]string{ 1: "aaa", 2:"bbb"}	保证key彼此不重复。
  
  	2. m := map[int]string{ 1: "aaa", 2:"bbb"}
  
  赋值:
  
  	赋值过程中，如果新map元素的key与原map元素key 相同 	——> 覆盖（替换）
  
  	赋值过程中，如果新map元素的key与原map元素key 不同	——> 添加
  
  map的使用：
  		  
  	遍历map：
  
  		for  key值， value值 := range map {
  		} 
  
  		for  key值 := range map {
  		}	
  
  	判断map中key是否存在。
  
  		 map[下标] 运算：返回两个值， 第一个表 value 的值，如果value不存在。 nil
  		第二个表 key是否存在的bool类型。存在 true， 不存在false
  
  	删除map：
  		delete()函数： 参1： 待删除元素的map	参2： key值
  		delete（map， key）删除一个不存在的key ， 不会报错。
  		map 做函数参数和返回值，传引用。
```

#### 4.4 结构体

构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。

```go
type Employee struct {
    ID        int
    Name      string
    Address   string
    DoB       time.Time
    Position  string
    Salary    int
    ManagerID int
}

var dilbert Employee
```

dilbert结构体变量的成员可以通过点操作符访问，比如dilbert.Name和dilbert.DoB。因为dilbert是一个变量，它所有的成员也同样是变量，我们可以直接对每个成员赋值：

```Go
dilbert.Salary -= 5000 // demoted, for writing too few lines of code
```

或者是对成员取地址，然后通过指针访问：

```Go
position := &dilbert.Position
*position = "Senior " + *position // promoted, for outsourcing to Elbonia
```

结构体成员的输入顺序也有重要的意义，那样的话就是定义了不同的结构体类型。

如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。

一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适用于数组。）但是S类型的结构体可以包含`*S`指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。

1) 结构体字面值

结构体值也可以用结构体字面值表示，结构体字面值可以指定每个成员的值。

```Go
type Point struct{ X, Y int }

p := Point{1, 2}
```

其实更常用的是第二种写法，以成员名字和相应的值来初始化，可以包含部分或全部的成员，如：

```Go
anim := gif.GIF{LoopCount: nframes}
```

两种不同形式的写法不能混合使用。而且，你不能企图在外部包中用第一种顺序赋值的技巧来偷偷地初始化结构体中未导出的成员。

2）结构体比较

如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，那样的话两个结构体将可以使用==或!=运算符进行比较。相等比较运算符==将比较两个结构体的每个成员，因此下面两个比较的表达式是等价的：

```Go
type Point struct{ X, Y int }

p := Point{1, 2}
q := Point{2, 1}
fmt.Println(p.X == q.X && p.Y == q.Y) // "false"
fmt.Println(p == q)                   // "false"
```

3） 结构体嵌入和匿名成员

使用Go语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符x.f来访问匿名成员链中嵌套的x.d.e.f成员。

Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。

```Go
type Circle struct {
    Point
    Radius int
}

type Wheel struct {
    Circle
    Spokes int
}
```

我们看到匿名成员特性只是对访问嵌套成员的点运算符提供了简短的语法糖。其实任何命名的类型都可以作为结构体的匿名成员。但是为什么要嵌入一个没有任何子成员类型的匿名成员类型呢？答案是匿名类型的方法集。

简短的点运算符语法可以用于选择匿名成员嵌套的成员，也可以用于访问它们的方法。实际上，外层的结构体不仅仅是获得了匿名成员类型的所有成员，而且也获得了该类型导出的全部的方法。这个机制可以用于将一些有简单行为的对象组合成有复杂行为的对象。组合是Go语言中面向对象编程的核心。

#### 4.5 JSON

JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。

JSON是对JavaScript中各种类型的值——字符串、数字、布尔值和对象——Unicode本文编码。

一个JSON数组是一个有序的值序列，写在一个方括号中并以逗号分隔；一个JSON数组可以用于编码Go语言的数组和slice。一个JSON对象是一个字符串到值的映射，写成一系列的name:value对形式，用花括号包含并以逗号分隔；JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体。

```Go
type Movie struct {
    Title  string
    Year   int  `json:"released"`
    Color  bool `json:"color,omitempty"`
    Actors []string
}

var movies = []Movie{
    {Title: "Casablanca", Year: 1942, Color: false,
        Actors: []string{"Humphrey Bogart", "Ingrid Bergman"}},
    {Title: "Cool Hand Luke", Year: 1967, Color: true,
        Actors: []string{"Paul Newman"}},
    {Title: "Bullitt", Year: 1968, Color: true,
        Actors: []string{"Steve McQueen", "Jacqueline Bisset"}},
    // ...
}
```

这样的数据结构特别适合JSON格式，并且在两者之间相互转换也很容易。将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）。编组通过调用json.Marshal函数完成，Marshal函数返回一个编码后的字节slice，包含很长的字符串，并且没有空白缩进。

只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。

编码的逆操作是解码，对应将JSON数据解码为Go语言的数据结构，Go语言中一般叫unmarshaling，通过json.Unmarshal函数完成。

#### 4.6 文本与HTML模板

前面的例子，只是最简单的格式化，使用Printf是完全足够的。但是有时候会需要复杂的打印格式，这时候一般需要将格式化代码分离出来以便更安全地修改。这些功能是由text/template和html/template等模板包提供的，它们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。

一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的`{{action}}`对象。

大部分的字符串只是按字面值打印，但是对于actions部分将触发其它的行为。每个actions都包含了一个用模板语言书写的表达式，一个action虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流if-else语句和range循环语句，还有其它实例化模板等诸多特性。下面是一个简单的模板字符串：

*gopl.io/ch4/issuesreport*

```Go
const templ = `{{.TotalCount}} issues:
{{range .Items}}----------------------------------------
Number: {{.Number}}
User:   {{.User.Login}}
Title:  {{.Title | printf "%.64s"}}
Age:    {{.CreatedAt | daysAgo}} days
{{end}}`
```

在一个action中，`|`操作符表示将前一个表达式的结果作为后一个函数的输入，类似于UNIX中管道的概念。

注意方法调用链的顺序：template.New先创建并返回一个模板；Funcs方法将daysAgo等自定义函数注册到模板中，并返回模板；最后调用Parse函数分析模板。

```Go
report, err := template.New("report").
    Funcs(template.FuncMap{"daysAgo": daysAgo}).
    Parse(templ)
if err != nil {
    log.Fatal(err)
}
```

一旦模板已经创建、注册了daysAgo函数、并通过分析和检测，我们就可以使用github.IssuesSearchResult作为输入源、os.Stdout作为输出源来执行模板：

```Go
var report = template.Must(template.New("issuelist").
    Funcs(template.FuncMap{"daysAgo": daysAgo}).
    Parse(templ))

func main() {
    result, err := github.SearchIssues(os.Args[1:])
    if err != nil {
        log.Fatal(err)
    }
    if err := report.Execute(os.Stdout, result); err != nil {
        log.Fatal(err)
    }
}
```

下面的模板以HTML格式输出issue列表。

```Go
import "html/template"

var issueList = template.Must(template.New("issuelist").Parse(`
<h1>{{.TotalCount}} issues</h1>
<table>
<tr style='text-align: left'>
  <th>#</th>
  <th>State</th>
  <th>User</th>
  <th>Title</th>
</tr>
{{range .Items}}
<tr>
  <td><a href='{{.HTMLURL}}'>{{.Number}}</a></td>
  <td>{{.State}}</td>
  <td><a href='{{.User.HTMLURL}}'>{{.User.Login}}</a></td>
  <td><a href='{{.HTMLURL}}'>{{.Title}}</a></td>
</tr>
{{end}}
</table>
`))
```

## GO语言基础学习

1、通道和并发

```go
go func chan int) { //读写均可的channel c } (a)
go func(c <- chan int) { //只读的Channel } (a)
go func(c chan <- int) {  //只写的Channel } (a)
```

2、接口对象执行的类型动态转换/查询——类型断言

```go
//1、具体值的类型断言
a,ok :=v.([]byte)//判断接口v的底层是否保存了字节切片类型的值，如果有，就返回ok=1 

//2、接口类型的类型断言，还未搞懂
type arg interface {}
a := arg.(int) //将arg保存的底层int值传给a，如果arg接口没有Int值，会panic

```

4、下面的条件语句中的中断命令跳出循环的情况。

```go
for i:=range A {
	switch {
	case n==1:
		break //这里的break没有作用，因为会默认为跳出switch
	case n!=1:
		continue //这里的continue是有作用的，可以跳出本次for循环
	}
    
    //下面的都能跳出for循环
	if n>1 {
		break
	}
	if n<1 {
		continue
	}
}
```

 